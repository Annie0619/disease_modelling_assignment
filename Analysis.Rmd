---
title: "Main Analysis"
author: "Andomei Smit: SMTAND051"
date: "30/09/2025"
output:
  bookdown::pdf_document2:
    toc: true
    toc_depth: 2
    fig_caption: true
    keep_tex: true
---

# Setup

```{r}
# ---- setup: packages & knitr ----
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(readr); library(dplyr); library(tidyr); library(stringr); library(tibble)
library(deSolve); library(ggplot2); library(scales)
library(knitr)

# ---- load config knobs ----
source("R/config.R")
# ---- load the engine functions (purl'ed script) ----
source("R/engine.R")
```

# Load data

```{r}
# ---- data: load processed inputs ----
proc_dir <- "data/processed"

# Population at start_year (sex, age, pop)
pop_sy <- readr::read_csv(file.path(proc_dir, "pop_age_sex.csv"), show_col_types = FALSE) |>
  dplyr::filter(year == start_year) |>
  dplyr::select(sex, age, pop)

# Mortality for the whole simulation window (year, sex, age, mu)
sim_years <- start_year:(start_year + horizon_years - 1)
mu_tbl <- readr::read_csv(file.path(proc_dir, "mortality_singleyear.csv"), show_col_types = FALSE) |>
  dplyr::filter(year %in% sim_years) |>
  dplyr::select(year, sex, age, mu)

# Births, coverage, pregnancy prevalence
births_df   <- readr::read_csv(file.path(proc_dir, "births.csv"), show_col_types = FALSE)
coverage_df <- readr::read_csv(file.path(proc_dir, "coverage.csv"), show_col_types = FALSE)
preg_prev   <- readr::read_csv(file.path(proc_dir, "pregnancy_prevalence.csv"), show_col_types = FALSE)

# ---- calibration: load WHO fit data ----
# Uses data/processed/cases_fit.csv that was created in Data prep
cases_fit <- readr::read_csv("data/processed/cases_fit.csv", show_col_types = FALSE)
stopifnot(all(c("year","cases_reported_total") %in% names(cases_fit)))


# ---- guardrails: inputs must cover sim years & plausible ranges ----
stopifnot(all(sim_years %in% unique(mu_tbl$year)))
stopifnot(all(sim_years %in% unique(births_df$year)))
stopifnot(all(sim_years %in% unique(coverage_df$year)))
stopifnot(all(preg_prev$age >= 15 & preg_prev$age <= 44))
```

# Quick smoke test

```{r}
# ---- build model object ----
mdl <- build_model(
  ages        = ages,
  sexes       = sexes,
  pop_sy      = pop_sy,
  mu_tbl      = mu_tbl,
  births_df   = births_df,
  coverage_df = coverage_df,
  preg_prev   = preg_prev
)

# ---- initial state (seeds 1 infection per (sex,age) cell) ----
y0 <- build_initial_state(mdl, seed_I_per_cell = 1L)

# ---- parameters (placeholders; beta & rho will be fitted later) ----
parms <- list(
  sigma = 1 / latent_period_years,
  gamma = 1 / infectious_period_years,
  beta  = beta,   # from config.R (placeholder)
  rho   = rho,    # from config.R (placeholder)
  VE    = VE
)

# ---- tiny smoke test: 2 years to verify ODE + events + μ-by-year ----
smoke <- run_horizon_mdl(
  y_start     = y0,
  start_year  = start_year,
  n_years     = 2,
  pr          = parms,
  mdl         = mdl,
  share_F     = share_F,
  share_M     = share_M,
  crs_parms   = crs_parms,
  tri_weights = tri_weights
)

smoke$results
```

# Burn-in

We want the model to start at a plausible endemic state, thus we simulate the model for K years prior to the window of the analysis for it to reach equilibrium.

```{r}
# ---- burn-in config knobs ----
burn_in_years <- 30          # set 0 to skip burn-in entirely
burn_ref_year <- start_year  # reuse demography from this year during burn-in

# Target R0 during burn-in (plausible pre-vax rubella 5–8). Converted to beta via beta = R0 * gamma.
R0_burnin <- 8
```

```{r}
# ---- burn-in run  ----
# Build a parameter list used ONLY during burn-in. We swap in beta to match R0_burnin.
parms_pre <- list(
  sigma = 1 / latent_period_years,
  gamma = 1 / infectious_period_years,
  beta  = R0_burnin * (1 / infectious_period_years),  # beta = R0 * gamma
  rho   = rho,   # unused in burn-in; harmless placeholder
  VE    = VE,     # unused in burn-in (no vaccination); harmless placeholder
  eps = 1e-8
)

# Either do burn-in (K > 0) or just pass through y0
if (burn_in_years > 0) {
  message("Burn-in: K=", burn_in_years, " years; R0=", R0_burnin,
          " (beta=", round(parms_pre$beta, 3), "); stationary demography from ", burn_ref_year)
  y_start_policy <- burn_in_mdl(
    y_start   = y0,
    start_year = start_year,
    K          = burn_in_years,
    pr         = parms_pre,
    mdl        = mdl,
    ref_year   = burn_ref_year,
    share_F    = share_F,
    share_M    = share_M
  )
} else {
  message("Burn-in skipped; using y0 directly.")
  y_start_policy <- y0
}
```
```{r}
# ---- post-burn-in smoke test ----
# Policy parameters (still placeholders; we'll fit beta & rho in Step 3)
parms_policy <- list(
  sigma = 1 / latent_period_years,
  gamma = 1 / infectious_period_years,
  beta  = beta,
  rho   = rho,
  VE    = VE
)

smoke_after_burnin <- run_horizon_mdl(
  y_start     = y_start_policy,
  start_year  = start_year,
  n_years     = 2,              # just a short check
  pr          = parms_policy,
  mdl         = mdl,
  share_F     = share_F,
  share_M     = share_M,
  crs_parms   = crs_parms,
  tri_weights = tri_weights
)

smoke_after_burnin$results
```
```{r}
# ---- optional diagnostics ----
cat("Policy R0 ≈ ", round(parms_policy$beta / parms_policy$gamma, 3), "\n")

N0 <- sum(y_start_policy[mdl$idx$S] + y_start_policy[mdl$idx$E] +
          y_start_policy[mdl$idx$I] + y_start_policy[mdl$idx$R])
cat("Total population at policy start: ", format(N0, big.mark=","), "\n")

I0 <- sum(y_start_policy[mdl$idx$I])
cat("Infectious at policy start (sum over all ages/sexes): ", round(I0), "\n")
```

```{r}
# Inspect infectious prevalence after burn-in with more precision
I0      <- sum(y_start_policy[mdl$idx$I])
N0      <- sum(y_start_policy[mdl$idx$S] + y_start_policy[mdl$idx$E] +
               y_start_policy[mdl$idx$I] + y_start_policy[mdl$idx$R])
prev_I0 <- I0 / N0

cat(sprintf("I0 (exact) = %.6f\n", I0))
cat(sprintf("N0 (exact) = %.0f\n", N0))
cat(sprintf("Prev_I0 = %.8f (%.3f per 100k)\n", prev_I0, prev_I0*1e5))

```

# Validate the R0 and rho values found in literature

```{r}
# ---- calibration: validation-only obs vs exp (literature-locked) ----
# Fitting/validation window and reference demography for stationary runs
fit_years      <- 2012:2019
fit_ref_demog  <- start_year         # use mortality from policy start for stationary demography
R0_lit_central <- 7.5                # literature anchor
rho_lit_central <- 0.005             # literature anchor for reporting

# Parameters for the stationary, no-vaccination fit-window run
parms_fit <- list(
  sigma = 1 / latent_period_years,
  gamma = 1 / infectious_period_years,
  beta  = R0_lit_central * (1 / infectious_period_years),
  rho   = rho_lit_central,
  VE    = VE,
  eps   = 1e-8
)

# Burn-in ending just before the first fit year, under the same parameters
burnin_years_fit <- 20
y_burn_fit <- burn_in_mdl(
  y_start    = y0,
  start_year = min(fit_years),
  K          = burnin_years_fit,
  pr         = parms_fit,
  mdl        = mdl,
  ref_year   = fit_ref_demog,
  share_F    = share_F,
  share_M    = share_M
)

# Stationary, no-vaccination simulation across fit years
sim_fit <- run_stationary_novax(
  y_start = y_burn_fit,
  years   = fit_years,
  pr      = parms_fit,
  mdl     = mdl,
  ref_year = fit_ref_demog,
  share_F = share_F,
  share_M = share_M
)

# Observed vs expected (literature-locked)
fit_compare_locked <- cases_fit %>%
  dplyr::filter(year %in% fit_years) %>%
  dplyr::inner_join(sim_fit$results %>% dplyr::select(year, infections_total), by = "year") %>%
  dplyr::transmute(
    year,
    obs = cases_reported_total,
    exp_locked = parms_fit$rho * infections_total
  )

print(fit_compare_locked)

# Optional: a one-parameter rescale of rho to match mean level (not a full likelihood fit)
rho_hat <- sum(fit_compare_locked$obs, na.rm = TRUE) / sum(sim_fit$results$infections_total, na.rm = TRUE)
fit_compare_scaled <- fit_compare_locked %>%
  dplyr::mutate(exp_scaled = rho_hat * (sim_fit$results$infections_total[match(year, sim_fit$results$year)]))

cat(sprintf("rho_lit_central = %.5f; rho_hat (mean-level) = %.5f\n", rho_lit_central, rho_hat))
```


```{r}
# ---- validation: final figure & CSV ---------------------------------------
# Join observed with expected series
val_df <- cases_fit %>%
  dplyr::select(year, obs = cases_reported_total) %>%
  dplyr::inner_join(
    sim_fit$results %>% dplyr::select(year, infections_total),
    by = "year"
  ) %>%
  dplyr::mutate(
    exp_lit    = parms_fit$rho * infections_total,      # Expected using literature rho
    exp_scaled = rho_hat        * infections_total       # Expected using scaled rho-hat
  ) %>%
  dplyr::select(year, obs, exp_lit, exp_scaled)

# Tidy (long) table for plotting and export
val_long <- val_df %>%
  tidyr::pivot_longer(
    cols = c(obs, exp_lit, exp_scaled),
    names_to = "series",
    values_to = "value"
  ) %>%
  dplyr::mutate(
    # Human-friendly legend with math where appropriate
    series = factor(series,
      levels = c("obs","exp_lit","exp_scaled"),
      labels = c(
        "Observed (reported)",
        "Expected (\\u03C1\\u0302[lit])",      # "ρ̂[lit]" via plotmath later
        "Expected (\\u03C1\\u0302[scaled])"   # "ρ̂[scaled]"
      )
    )
  )

# Save the tidy table for the report appendix
readr::write_csv(val_long, "outputs/validation_obs_exp.csv")
message("Saved: outputs/validation_obs_exp.csv")

# --- VALIDATION PLOT (no subtitle; math labels via manual scales) ----------
series_labels <- c(
  "Observed (reported)"             = "Observed~(reported)",
  "Expected (\\u03C1\\u0302[lit])"     = "Expected~~~(hat(rho)[lit])",
  "Expected (\\u03C1\\u0302[scaled])"  = "Expected~~~(hat(rho)[scaled])"
)

p_val <- ggplot(val_long, aes(x = year, y = value/1000, linetype = series, color = series)) +
  geom_line(linewidth = 1.0) +
  geom_point(
    data = subset(val_long, series == "Observed (reported)"),
    size = 1.8, show.legend = FALSE
  ) +
  scale_y_continuous(
    name   = "Reported cases (thousands)",
    labels = scales::comma
  ) +
  scale_linetype_manual(
    values = c(
      "Observed (reported)"             = "solid",
      "Expected (\\u03C1\\u0302[lit])"     = "dashed",
      "Expected (\\u03C1\\u0302[scaled])"  = "dotdash"
    ),
    labels = scales::label_parse()(series_labels[levels(val_long$series)])
  ) +
  scale_color_manual(
    values = c(
      "Observed (reported)"             = "#1b9e77",
      "Expected (\\u03C1\\u0302[lit])"     = "#d95f02",
      "Expected (\\u03C1\\u0302[scaled])"  = "#7570b3"
    ),
    labels = scales::label_parse()(series_labels[levels(val_long$series)])
  ) +
  guides(
    linetype = guide_legend(title = NULL, label.hjust = 0),
    color    = "none"
  ) +
  labs(
    title = "Observed vs expected reported rubella cases",
    x = "Year"
  ) +
  theme_bw(base_size = 15) +
  theme(
    legend.position   = "right",
    legend.box        = "vertical",
    legend.text       = element_text(size = 12),
    panel.grid.minor  = element_blank(),
    plot.title        = element_text(face = "bold")
  )

ggsave("plots/validation_obs_vs_exp.png", p_val, width = 7, height = 4, dpi = 400)
message("Saved: plots/validation_obs_vs_exp.png")
```


# Add diagnostics for mean age of infection

```{r}
# ---------------------------------------------
# Helper: mean age at infection among females 15–44
# Inputs:
#   C_F_vec : numeric vector of length mdl$n_age; infections in females by single-year age
#   mdl     : model object (to access 'ages')
# Returns:
#   Weighted mean age over ages 15..44, or NA if no infections in that range
mean_age_infection_f1544 <- function(C_F_vec, mdl) {
  stopifnot(length(C_F_vec) == mdl$n_age)
  a <- mdl$ages
  sel <- (a >= 15 & a <= 44)
  w <- C_F_vec[sel]
  if (sum(w) <= 0) return(NA_real_)
  sum(a[sel] * w) / sum(w)
}

# ---------------------------------------------
# Runner that adds "paradox" diagnostics
# Mirrors run_horizon_mdl, but also records:
#   - inf_F1544        : infections in females aged 15–44 (per year)
#   - mean_age_F1544   : mean age of infection in females 15–44 (per year)
#
# Note: We reuse the same ODE + events; we only add post-processing.
run_horizon_with_paradox <- function(y_start, start_year, n_years, pr, mdl, share_F, share_M, crs_parms, tri_weights) {
  yrs <- seq.int(from = start_year, length.out = n_years)
  out <- tibble::tibble(
    year = integer(),
    infections_total = double(),
    reported_cases   = double(),
    crs              = double(),
    inf_F1544        = double(),
    mean_age_F1544   = double()
  )

  y_curr <- y_start

  for (yr in yrs) {
    # Reset yearly counters (accumulators) before integrating the year
    y_curr[mdl$idx$C_F]  <- 0
    y_curr[mdl$idx$C_tot] <- 0

    # Integrate ODE over the calendar year and apply events
    res   <- simulate_one_year_mdl(y_curr, yr, pr, mdl, share_F, share_M)

    # Read end-of-year accumulators BEFORE events are applied
    y_pre <- as.numeric(res$trajectory[nrow(res$trajectory), -1])
    C_F_end   <- y_pre[mdl$idx$C_F]           # female infections by age
    C_tot_end <- as.numeric(y_pre[mdl$idx$C_tot])

    # Compute CRS using your existing helper
    crs_year <- crs_from_infections_mdl(C_F_end, mdl, r = crs_parms, w = tri_weights)

    # Compute paradox diagnostics
    a <- mdl$ages
    sel <- (a >= 15 & a <= 44)
    inf_F1544      <- sum(C_F_end[sel])
    mean_age_F1544 <- mean_age_infection_f1544(C_F_end, mdl)

    out <- dplyr::bind_rows(out, tibble::tibble(
      year = yr,
      infections_total = C_tot_end,
      reported_cases   = if (!is.null(pr$rho) && is.finite(pr$rho)) pr$rho * C_tot_end else NA_real_,
      crs              = crs_year,
      inf_F1544        = inf_F1544,
      mean_age_F1544   = mean_age_F1544
    ))

    # Roll state forward (post-events state becomes next year's start)
    y_curr <- res$y_next
  }

  list(results = out, y_final = y_curr)
}
```

# Policy Scenario Testing

```{r}
# ---- Build a coverage table for a scenario (with optional age-band) ----
# years         : integer vector for policy years
# p_routine     : routine coverage in [0,1]
# campaign_year : integer year for one-time catch-up (or NULL for none)
# p_catchup     : catch-up coverage in [0,1]
# catch_min_age : integer lower bound (default 1)
# catch_max_age : integer upper bound, inclusive (default 14)
# catch_age0_frac : numeric in (0,1], only used if min_age == 0 (default NA => treat as 1 for age 0)
make_coverage_scenario <- function(
    years,
    p_routine,
    campaign_year = NULL,
    p_catchup     = NULL,
    catch_min_age = 1L,
    catch_max_age = 14L,
    catch_age0_frac = NA_real_
) {
  stopifnot(p_routine >= 0, p_routine <= 1)

  cov <- tibble::tibble(
    year = years,
    routine_coverage = p_routine,
    catchup_coverage = NA_real_,
    catch_min_age    = as.integer(catch_min_age),
    catch_max_age    = as.integer(catch_max_age),
    catch_age0_frac  = as.numeric(catch_age0_frac)
  )

  if (!is.null(campaign_year)) {
    stopifnot(campaign_year %in% years)
    stopifnot(!is.null(p_catchup), p_catchup >= 0, p_catchup <= 1)
    cov$catchup_coverage[cov$year == campaign_year] <- p_catchup
  }

  cov
}
```


```{r}
# define and run scenarios
# ---------------------------------------------
# Helper: shallow-clone the model and override coverage
clone_with_coverage <- function(mdl, coverage_new) {
  mdl2 <- mdl
  mdl2$coverage_df <- coverage_new
  mdl2
}

# ---- helpers: campaign labeling and zero-vax delay handling ----

# ---- helper: vectorized campaign label -----------------------------------
campaign_label <- function(campaign_year, start_year) {
  # Returns "none", "immediate", or "delayed{k}y" for each element of campaign_year
  out <- ifelse(
    is.na(campaign_year), "none",
    ifelse(
      campaign_year == start_year, "immediate",
      paste0("delayed", as.integer(campaign_year - start_year), "y")
    )
  )
  out
}


# ---- helper: delay handling with optional routine suspension -------------
# Suppress catch-up before the campaign year. Optionally set routine=0
# during the delay window (years: start_year .. campaign_year-1).
apply_delay <- function(cov_tbl, start_year, campaign_year, zero_routine = TRUE) {
  if (is.na(campaign_year) || campaign_year <= start_year) return(cov_tbl)
  delay_years <- seq.int(start_year, campaign_year - 1L)
  # Catch-up is always absent before the campaign
  cov_tbl$catchup_coverage[cov_tbl$year %in% delay_years] <- NA_real_
  # Optionally suspend routine during the delay
  if (isTRUE(zero_routine)) {
    cov_tbl$routine_coverage[cov_tbl$year %in% delay_years] <- 0
  }
  cov_tbl
}
```


Compare multiple years.

```{r}
# ---------------------------------------------
# Define locked literature parameters/burn-in
R0_lit_central   <- 7.9            # SA anchor; vary in sensitivity later
rho_lit_central  <- 0.01

parms_locked <- list(
  sigma = 1 / latent_period_years,
  gamma = 1 / infectious_period_years,
  beta  = R0_lit_central * (1 / infectious_period_years),
  rho   = rho_lit_central,
  VE    = VE,
  eps   = 1e-8
  )

y_start_locked <- burn_in_mdl(
 y_start    = y0,
  start_year = start_year,
  K          = 30, # 30 year burn in
  pr         = parms_locked,
  mdl        = mdl,
  ref_year   = start_year,
  share_F    = share_F,
  share_M    = share_M
)
```


```{r}
# ---- scenarios: define with campaign_year; labels derived by helper ----

# Policy years
years_policy <- start_year:(start_year + horizon_years - 1)

# Define a compact set of illustrative scenarios (mix of routine, catch-up %, and delays)
# ---- scenarios: add age-band columns and two 9m–9y variants ----
scenarios <- tibble::tibble(
  id         = c("r80_none", "r90_none",
                 "r80_c90_now", "r90_c90_now",
                 "r90_c90_d1", "r90_c90_d2", "r90_c90_d3",
                 "r90_c90_d1_keepR", "r90_c90_d2_keepR", "r90_c90_d3_keepR",
                 "r90_c90_now_9m9y", "r90_c90_d1_9m9y_keepR"),
  routine    = c(0.80, 0.90,
                 0.80, 0.90,
                 0.90, 0.90, 0.90,
                 0.90, 0.90, 0.90,
                 0.90, 0.90),
  catch_cov  = c(NA,   NA,
                 0.90, 0.90,
                 0.90, 0.90, 0.90,
                 0.90, 0.90, 0.90,
                 0.90, 0.90),
  catch_year = c(NA,   NA,
                 start_year, start_year,
                 start_year + 1L, start_year + 2L, start_year + 3L,
                 start_year + 1L, start_year + 2L, start_year + 3L,
                 start_year,       start_year + 1L),
  delay_zero_routine = c(FALSE, FALSE,
                         FALSE, FALSE,
                         TRUE, TRUE, TRUE,
                         FALSE, FALSE, FALSE,
                         FALSE, FALSE),
  # Default band: 1–14 (full age-0 not used)
  catch_min_age = c(rep(1L, 10),   0L,              0L),
  catch_max_age = c(rep(14L, 10),  9L,              9L),
  catch_age0_frac = c(rep(NA_real_, 10), 0.25,      0.25)
) %>%
  dplyr::mutate(
    band_label = dplyr::if_else(catch_min_age == 0L,
                                "9m–9y", "1–14y"),
    label = dplyr::case_when(
      is.na(catch_year) ~ paste0("Routine ", scales::percent(routine), " (no catch-up)"),
      !delay_zero_routine & (catch_year > start_year) ~ paste0(
        "Catch-up ", band_label, " @", scales::percent(catch_cov),
        " (", campaign_label(catch_year, start_year), ", routine ON), Routine ", scales::percent(routine)
      ),
      TRUE ~ paste0(
        "Catch-up ", band_label, " @", scales::percent(catch_cov),
        " (", campaign_label(catch_year, start_year), "), Routine ", scales::percent(routine)
      )
    )
  )


# ---- run scenarios using generic delay handler + auto labels ----
scenario_results <- list()

for (i in seq_len(nrow(scenarios))) {
  sc <- scenarios[i, ]

  # Build coverage for this scenario
  # Build coverage for this scenario (pass age-band parameters)
  cov_tbl <- make_coverage_scenario(
    years           = years_policy,
    p_routine       = sc$routine,
    campaign_year   = if (is.na(sc$catch_year)) NULL else sc$catch_year,
    p_catchup       = if (is.na(sc$catch_cov))  NULL else sc$catch_cov,
    catch_min_age   = sc$catch_min_age,
    catch_max_age   = sc$catch_max_age,
    catch_age0_frac = sc$catch_age0_frac
  )

  # Enforce delay rule: always suppress catch-up before campaign; optionally suspend   routine
  cov_tbl <- apply_delay(
    cov_tbl,
    start_year     = start_year,
    campaign_year  = sc$catch_year,
    zero_routine   = sc$delay_zero_routine
  )

  # Clone model with scenario-specific coverage
  mdl_sc <- clone_with_coverage(mdl, cov_tbl)

  # Run with paradox diagnostics
  run_sc <- run_horizon_with_paradox(
    y_start     = y_start_locked,
    start_year  = start_year,
    n_years     = horizon_years,
    pr          = parms_locked,
    mdl         = mdl_sc,
    share_F     = share_F,
    share_M     = share_M,
    crs_parms   = crs_parms,
    tri_weights = tri_weights
  )

  df <- run_sc$results

  CRS10_val <- crs_sum_window(df, start_year = start_year, years = 10)
  CRS25_val <- crs_sum_window(df, start_year = start_year, years = 25)

  scenario_results[[sc$id]] <- list(
    summary  = tibble::tibble(
    id         = sc$id,
    label      = sc$label,
    routine    = sc$routine,
    catch_year = sc$catch_year,
    catch_cov  = sc$catch_cov,
    campaign   = campaign_label(sc$catch_year, start_year),
    CRS10      = CRS10_val,
    CRS25      = CRS25_val,
    cum_inf_F1544      = sum(df$inf_F1544, na.rm = TRUE),
    mean_age_F1544_avg = mean(df$mean_age_F1544, na.rm = TRUE)
  ),
  timeseries = df,
  coverage   = cov_tbl
)
}

# Collect a summary table
scenario_summary <- dplyr::bind_rows(lapply(scenario_results, `[[`, "summary")) %>%
  dplyr::arrange(CRS10)
```

How much better is this than baseline.

```{r}
# ---- Baseline-locked averted metrics (baseline = r80_none only) ----------
# 1) Find r80_none baseline row
base80 <- scenario_summary %>%
  filter(is.na(catch_year), abs(routine - 0.80) < 1e-9) %>%
  slice(1)
stopifnot(nrow(base80) == 1)

# 2) Add baseline-locked columns
scenario_summary <- scenario_summary %>%
  mutate(
    Averted10_base80 = base80$CRS10 - CRS10,
    Averted25_base80 = base80$CRS25 - CRS25,
    # For backward compatibility in existing code:
    Averted = Averted10_base80
  )

# 3) Save a clean copy for the report
readr::write_csv(scenario_summary, "outputs/scenario_summary.csv")
message("Saved: outputs/scenario_summary.csv")
```

## Some plots

```{r}
# ---- SCENARIOS: helpers for plotting ----

# Get timeseries df for a scenario id (adds 'id' and 'label')
get_ts <- function(id) {
  stopifnot(id %in% names(scenario_results))
  df <- scenario_results[[id]]$timeseries
  lab <- scenario_summary$label[match(id, scenario_summary$id)]
  df$id <- id
  df$label <- ifelse(is.na(lab), id, lab)
  df
}

# Common y-scale in thousands
scale_y_thousands <- scale_y_continuous(
  name = "CRS (thousands)",
  labels = function(x) scales::comma(x/1000)
)

# Save convenience
save_plot <- function(p, path, w = 10, h = 5, dpi = 400) {
  ggplot2::ggsave(path, plot = p, width = w, height = h, dpi = dpi)
  message("Saved: ", path)
}
```

## Compare baseline to increase routine to 90%

```{r}
# ---- SCENARIOS: CRS time-series (key scenarios) ----
ids_focus <- c("r80_none", "r90_none")
ids_focus <- ids_focus[ids_focus %in% names(scenario_results)]  # guard

ts_focus <- dplyr::bind_rows(lapply(ids_focus, get_ts))

# Order legend by 10-year averted vs r80_none (descending)
ord <- scenario_summary %>%
  dplyr::filter(id %in% ids_focus) %>%
  dplyr::arrange(dplyr::desc(Averted10_base80))

ts_focus$label <- factor(ts_focus$label, levels = ord$label)


p_ts <- ggplot(ts_focus, aes(x = year, y = crs, color = label)) +
  geom_line(linewidth = 1.05) +
  scale_y_thousands +
  labs(
    title = "CRS over time: selected scenarios",
    x = "Year", color = NULL
  ) +
  theme_bw(base_size = 16) +
  theme(
    legend.position = "right",
    legend.text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold")
  )

save_plot(p_ts, "plots/scenario_crs_r90_none_r80_none.png")
```


## Compate r90_c90_now with delays

Start with the whole CRS timeseries for each.

```{r}
# 1) Guard: the four scenario IDs we want
ids_focus <- c("r90_c90_now","r90_c90_d1","r90_c90_d2","r90_c90_d3")
ids_focus <- ids_focus[ids_focus %in% names(scenario_results)]
stopifnot(length(ids_focus) > 0)

# 2) Minimal helper to fetch timeseries & label (no external dependency)
get_ts_local <- function(id) {
  stopifnot(id %in% names(scenario_results))
  df  <- scenario_results[[id]]$timeseries
  lbl <- scenario_summary$label[match(id, scenario_summary$id)]
  df$label <- ifelse(is.na(lbl), id, lbl)
  df$id    <- id
  df
}

# 3) Pull timeseries for chosen scenarios
ts_focus <- dplyr::bind_rows(lapply(ids_focus, get_ts_local))


# Order legend by 10-year averted vs r80_none (descending)
ord <- scenario_summary %>%
  dplyr::filter(id %in% ids_focus) %>%
  dplyr::arrange(dplyr::desc(Averted10_base80))

ts_focus$label <- factor(ts_focus$label, levels = ord$label)


# 6) Local y-scale in thousands so we don't rely on a prior helper
scale_y_thousands_local <- scale_y_continuous(
  name   = "CRS (thousands)",
  labels = function(x) scales::comma(x / 1000)
)

# 7) Plot
p_ts <- ggplot(ts_focus, aes(x = year, y = crs, color = label)) +
  geom_line(linewidth = 1.15) +
  scale_y_thousands_local +
  labs(
    title = "CRS over time: routine 90% with catch-up timing",
    subtitle = "Immediate vs delays (1–3 years) at 90% catch-up",
    x = "Year", color = NULL
  ) +
  theme_bw(base_size = 16) +
  theme(
    legend.position = "top",
    legend.text = element_text(size = 12),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold")
  ) +
  guides(color = guide_legend(nrow = 2, byrow = TRUE, override.aes = list(linewidth = 1.6)))

ggsave("plots/scenario_crs_r90_delays.png", p_ts, width = 10, height = 5, dpi = 400)
```

Now just plot 2025 to 2030:

```{r}
# Focus set (guard to only keep those that exist locally)
ids_focus <- c("r90_c90_now","r90_c90_d1","r90_c90_d2","r90_c90_d3")
ids_focus <- ids_focus[ids_focus %in% names(scenario_results)]
stopifnot(length(ids_focus) > 0)

# Minimal helper to fetch timeseries & readable label (no external helpers assumed)
get_ts_local <- function(id) {
  df  <- scenario_results[[id]]$timeseries
  lbl <- scenario_summary$label[match(id, scenario_summary$id)]
  df$label <- ifelse(is.na(lbl), id, lbl)
  df$id    <- id
  df
}

# Pull timeseries, then filter to 2025–2030 inclusive
ts_focus <- dplyr::bind_rows(lapply(ids_focus, get_ts_local)) %>%
  dplyr::filter(year >= 2025, year <= 2030)


# Order legend by 10-year averted vs r80_none (descending)
ord <- scenario_summary %>%
  dplyr::filter(id %in% ids_focus) %>%
  dplyr::arrange(dplyr::desc(Averted10_base80))
ts_focus$label <- factor(ts_focus$label, levels = ord$label)


# Local y-axis in thousands
scale_y_thousands_local <- scale_y_continuous(
  name   = "CRS (thousands)",
  labels = function(x) scales::comma(x / 1000)
)

# Plot (windowed years)
p_ts_win <- ggplot(ts_focus, aes(x = year, y = crs, color = label)) +
  geom_line(linewidth = 1.15) +
  scale_y_thousands_local +
  labs(
    title = "CRS over time (2025–2030): routine 90% with catch-up timing",
    subtitle = "Immediate vs delays (1–3 years) at 90% catch-up",
    x = "Year", color = NULL
  ) +
  theme_bw(base_size = 16) +
  theme(
    legend.position = "top",
    legend.text = element_text(size = 12),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold")
  ) +
  guides(color = guide_legend(nrow = 2, byrow = TRUE, override.aes = list(linewidth = 1.6)))

ggsave("plots/scenario_crs_r90_delays_2025_2030.png", p_ts_win, width = 10, height = 5, dpi = 400)
```

## CRS averted at 10y and 25y

```{r}
# ---- SCENARIOS: bar chart of averted CRS (10y & 25y) vs r80_none --------
# Use the baseline-locked columns already in scenario_summary
sc_bar <- scenario_summary %>%
  # Order by 10-year impact (descending)
  dplyr::arrange(dplyr::desc(Averted10_base80)) %>%
  dplyr::mutate(label = factor(label, levels = label))

sc_bar_long <- sc_bar %>%
  dplyr::select(label, Averted10_base80, Averted25_base80) %>%
  tidyr::pivot_longer(
    cols = c(Averted10_base80, Averted25_base80),
    names_to = "horizon", values_to = "averted"
  ) %>%
  dplyr::mutate(
    horizon = dplyr::recode(horizon,
                            Averted10_base80 = "CRS10",
                            Averted25_base80 = "CRS25")
  )

p_bar <- ggplot(sc_bar_long, aes(x = label, y = averted/1000, fill = horizon)) +
  geom_col(position = position_dodge(width = 0.75), width = 0.7) +
  coord_flip() +
  labs(
    title = "CRS averted vs baseline (r80_none)",
    x = NULL, y = "Averted CRS (thousands)", fill = NULL
  ) +
  scale_fill_brewer(palette = "Set2") +
  theme_bw(base_size = 16) +
  theme(
    legend.position = "top",
    legend.text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold")
  )

save_plot(p_bar, "plots/scenario_averted_bar.png")
```

## Mean age (F15-44)

```{r}
# ---- SCENARIOS: mean age of infection in females 15–44 (key scenarios) ----
ids_focus <- c("r90_c90_now", "r80_c90_now", "r90_c90_now_9m9y")
ids_focus <- ids_focus[ids_focus %in% names(scenario_results)]  # guard

ts_focus <- dplyr::bind_rows(lapply(ids_focus, get_ts))

ts_focus_ma <- ts_focus %>%
  dplyr::select(year, label, mean_age_F1544)

p_ma <- ggplot(ts_focus_ma, aes(x = year, y = mean_age_F1544, color = label)) +
  geom_line(linewidth = 1.05) +
  labs(
    title = "Mean age at infection (females 15–44)",
    x = "Year", y = "Mean age (years)", color = NULL
  ) +
  theme_bw(base_size = 16) +
  theme(
    legend.position = "right",
    legend.text = element_text(size = 13),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold")
  )

save_plot(p_ma, "plots/scenario_mean_age_f1544.png")
```


# Sensitivity check

```{r}
# ============================
# Sensitivity grid (parallel)
# ============================
# Parallelizes the scenario sweep across:
#   - R0 ∈ {6, 7, 8}
#   - routine ∈ {50%, 55%, ..., 95%}
#   - catch-up ∈ {0%, 10%, ..., 95%}
#   - campaign timing ∈ {immediate, +1y, +2y, +3y} for catch-up > 0
#
# Design:
#   1) Build a spec table of all combinations.
#   2) Map each row → run model → summarize CRS10/CRS25.
#   3) Compute averted vs baseline r80_none per R0.
#   4) Save to outputs/.
#

# ---- libraries for parallel & progress ----
suppressPackageStartupMessages({
  library(future.apply)   # parallel lapply
  library(progressr)      # progress bars
})

# ---- knobs to optionally thin the grid (for fast testing) ----
# Set to TRUE for a quick dry-run (much faster, fewer combos)
FAST_TEST <- FALSE

# ---- policy years & helper for windowed CRS sums ----
years_policy <- start_year:(start_year + horizon_years - 1)

crs_sum_window <- function(df, start_year, years) {
  # Sum CRS in [start_year, start_year + years - 1]
  stopifnot(all(c("year","crs") %in% names(df)))
  yr_max <- start_year + years - 1L
  sum(df$crs[df$year >= start_year & df$year <= yr_max], na.rm = TRUE)
}

# ---- grid choices (thin if FAST_TEST) ----
R0_vals      <- if (FAST_TEST) c(7.0)                else c(6.0, 7.0, 8.0)
routine_vals <- if (FAST_TEST) c(0.80, 0.90)         else seq(0.50, 0.95, by = 0.05)
catch_vals   <- if (FAST_TEST) c(0.00, 0.90)         else seq(0.00, 0.95, by = 0.10)
camp_years   <- if (FAST_TEST) c(start_year, start_year + 1L) else
                             c(start_year, start_year + 1L, start_year + 2L, start_year + 3L)

# ---- build spec table -----------------------------------------------------
# For catch-up = 0, force a single "none" campaign (campaign_year = NA).
# For catch-up > 0, include all camp_years.

spec_none <- expand.grid(
  R0 = R0_vals,
  routine = routine_vals,
  catchup = 0.00,
  campaign_year = NA_integer_,
  KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE
)

spec_some <- expand.grid(
  R0 = R0_vals,
  routine = routine_vals,
  catchup = setdiff(catch_vals, 0.00),
  campaign_year = camp_years,
  KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE
)

sens_spec <- dplyr::bind_rows(spec_none, spec_some) %>%
  dplyr::mutate(
    campaign = ifelse(is.na(campaign_year), "none", campaign_label(campaign_year, start_year))
  )

# ---- per-row runner -------------------------------------------------------
run_one_spec <- function(row) {
  # row: one row from sens_spec (data.frame-like, 1 row)
  R0v   <- row[["R0"]]
  pr    <- row[["routine"]]
  pc    <- row[["catchup"]]
  cy    <- row[["campaign_year"]]   # may be NA
  camp  <- row[["campaign"]]

  # Parameters for this R0 (beta = R0 * gamma)
  parms_sens <- parms_locked
  parms_sens$beta <- R0v * parms_locked$gamma

  # Coverage table for this scenario
  cov_tbl <- make_coverage_scenario(
    years         = years_policy,
    p_routine     = pr,
    campaign_year = if (is.na(cy)) NULL else cy,
    p_catchup     = if (is.na(cy)) NULL else pc
  )

  # Delay rule: suppress catch-up before campaign; routine continues during delay
  cov_tbl <- apply_delay(
    cov_tbl,
    start_year     = start_year,
    campaign_year  = cy,
    zero_routine   = FALSE
  )

  # Clone model with this coverage
  mdl_sc <- clone_with_coverage(mdl, cov_tbl)

  # Run horizon with paradox diagnostics (same horizon_years as elsewhere)
  run_sc <- run_horizon_with_paradox(
    y_start     = y_start_locked,
    start_year  = start_year,
    n_years     = horizon_years,
    pr          = parms_sens,
    mdl         = mdl_sc,
    share_F     = share_F,
    share_M     = share_M,
    crs_parms   = crs_parms,
    tri_weights = tri_weights
  )

  df <- run_sc$results

  # Summaries
  tibble::tibble(
    R0                 = R0v,
    routine            = pr,
    catchup            = pc,
    campaign           = camp,
    campaign_year      = if (is.na(cy)) NA_integer_ else cy,
    CRS10              = crs_sum_window(df, start_year = start_year, years = 10),
    CRS25              = crs_sum_window(df, start_year = start_year, years = 25),
    cum_inf_F1544      = sum(df$inf_F1544, na.rm = TRUE),
    mean_age_F1544_avg = mean(df$mean_age_F1544, na.rm = TRUE)
  )
}

# ---- parallel plan --------------------------------------------------------
# Use all available cores minus one. For Windows, 'multisession' is required.
workers <- max(1L, parallel::detectCores() - 1L)
future::plan(future::multisession, workers = workers)

# Optional: silence RNG warnings for nested parallel operations
options(future.rng.onMisuse = "ignore")

# ---- execute with progress -----------------------------------------------
with_progress({
  p <- progressor(steps = nrow(sens_spec))
  sens_list <- future_lapply(
    X = seq_len(nrow(sens_spec)),
    FUN = function(i) {
      # Progress tick (lightweight)
      p()
      run_one_spec(sens_spec[i, , drop = FALSE])
    }
  )
})

sens_grid <- dplyr::bind_rows(sens_list)

# ---- compute averted vs baseline r80_none per R0 --------------------------
base_key <- sens_grid %>%
  dplyr::filter(abs(routine - 0.80) < 1e-9, catchup == 0, campaign == "none") %>%
  dplyr::select(R0, CRS10_base = CRS10, CRS25_base = CRS25)

sens_grid <- sens_grid %>%
  dplyr::left_join(base_key, by = "R0") %>%
  dplyr::mutate(
    Averted10_base80 = CRS10_base - CRS10,
    Averted25_base80 = CRS25_base - CRS25
  )

# ---- factorize campaign facet order for plotting --------------------------
campaign_levels <- c("none", "immediate", "delayed1y", "delayed2y", "delayed3y")
sens_grid <- sens_grid %>%
  dplyr::mutate(campaign = factor(campaign, levels = campaign_levels))

# ---- save to disk ---------------------------------------------------------
readr::write_csv(sens_grid, "outputs/sensitivity_grid_r80baseline.csv")
message("Saved: outputs/sensitivity_grid_r80baseline.csv")
```

## Analyse the results

```{r}
# ============================
# Step 4B.1 — Compact summaries + 2 essential plots
# ============================

# Guard: expected columns present
stopifnot(all(c("R0","routine","catchup","campaign","CRS10","CRS25",
                "Averted10_base80","Averted25_base80") %in% names(sens_grid)))

# ---- 1) Small CSV summaries -----------------------------------------------
# Top scenarios by R0 (25y averted)
top_by_R0 <- sens_grid %>%
  dplyr::group_by(R0) %>%
  dplyr::arrange(dplyr::desc(Averted25_base80), .by_group = TRUE) %>%
  dplyr::slice_head(n = 8) %>%                              # keep 8 per R0 for quick scan
  dplyr::ungroup()

readr::write_csv(top_by_R0, "outputs/sens_top_by_R0_25y.csv")
message("Saved: outputs/sens_top_by_R0_25y.csv")

# Overall Top-N across R0 (25y averted)
top_overall <- sens_grid %>%
  dplyr::arrange(dplyr::desc(Averted25_base80)) %>%
  dplyr::slice_head(n = 15)

readr::write_csv(top_overall, "outputs/sens_top_overall_25y.csv")
message("Saved: outputs/sens_top_overall_25y.csv")


# ---- 2) Plot A — Heatmap (immediate only) ---------------------------------
# High signal, low clutter: only "immediate" campaign, facet by R0

hm_immediate <- sens_grid %>%
  dplyr::filter(campaign == "immediate") %>%
  ggplot(aes(x = routine, y = catchup, fill = Averted25_base80)) +
  geom_tile() +
  facet_wrap(~ R0, nrow = 1, labeller = label_both) +
  scale_fill_viridis_c(name = "CRS averted (25y)\nvs r80_none") +
  scale_x_continuous("Routine coverage", breaks = seq(0.5, 0.95, by = 0.05), limits = c(0.5, 0.95)) +
  scale_y_continuous("Catch-up coverage", breaks = seq(0, 0.95, by = 0.10), limits = c(0, 0.95)) +
  labs(title = "Sensitivity (immediate campaign): CRS averted over 25 years",
       subtitle = "Baseline = routine 80%, no catch-up") +
  theme_bw(base_size = 14) +
  theme(legend.position = "right",
        panel.grid.minor = element_blank(),
        plot.title = element_text(face = "bold"))

ggsave("plots/sens_heatmap_immediate_25y.png", hm_immediate, width = 12, height = 4.5, dpi = 400)
message("Saved: plots/sens_heatmap_immediate_25y.png")


# ---- 3) Plot B — Timing bars at fixed (routine, catchup) ------------------
# Shows short-term penalty (10y) vs long-term benefit (25y) across timings.
# Defaults: routine = 0.90, catchup = 0.90; adjust here if needed.
routine_fix <- 0.90
catchup_fix <- 0.90

timing_slice <- sens_grid %>%
  dplyr::filter(abs(routine - routine_fix) < 1e-9,
                abs(catchup - catchup_fix) < 1e-9,
                campaign %in% c("immediate","delayed1y","delayed2y","delayed3y")) %>%
  # reshape to long for twin bars (10y & 25y)
  dplyr::select(R0, campaign, Averted10_base80, Averted25_base80) %>%
  tidyr::pivot_longer(cols = c(Averted10_base80, Averted25_base80),
                      names_to = "horizon", values_to = "averted") %>%
  dplyr::mutate(
    horizon = dplyr::recode(horizon,
                            Averted10_base80 = "10y",
                            Averted25_base80 = "25y"),
    # order campaign timing in the intuitive order
    campaign = factor(campaign, levels = c("immediate","delayed1y","delayed2y","delayed3y"))
  )

p_timing <- ggplot(timing_slice, aes(x = campaign, y = averted/1000, fill = horizon)) +
  geom_hline(yintercept = 0, linewidth = 0.5, color = "grey60") +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  facet_wrap(~ R0, nrow = 1, labeller = label_both) +
  scale_fill_brewer(palette = "Set2", name = NULL) +
  labs(title = sprintf("Campaign timing at routine=%.0f%%, catch-up=%.0f%%", routine_fix*100, catchup_fix*100),
       subtitle = "Averted CRS vs r80_none (bars for 10y and 25y horizons)",
       x = NULL, y = "Averted CRS (thousands)") +
  theme_bw(base_size = 14) +
  theme(legend.position = "top",
        panel.grid.minor = element_blank(),
        plot.title = element_text(face = "bold"))

ggsave("plots/sens_timing_bars_r90_c90.png", p_timing, width = 12, height = 4.5, dpi = 400)
message("Saved: plots/sens_timing_bars_r90_c90.png")
```

### More focused slices

```{r}
# ============================
# Step 4B.2 — Focused sensitivity slices
# ============================

# Guard
stopifnot(exists("sens_grid"))
stopifnot(all(c("R0","routine","catchup","campaign","Averted10_base80","Averted25_base80") %in% names(sens_grid)))

# ----------------------------
# 1) Lines: Averted25 vs routine at several catch-up levels (immediate only), faceted by R0
# ----------------------------
catch_levels_show <- c(0.30, 0.60, 0.90)  # adjust if needed

line_immediate <- sens_grid %>%
  filter(campaign == "immediate", catchup %in% catch_levels_show)

# Save the slice as CSV for the appendix
readr::write_csv(line_immediate, "outputs/sens_slice_immediate_lines.csv")

p_line_imm <- ggplot(line_immediate,
                     aes(x = routine, y = Averted25_base80/1000, color = factor(catchup))) +
  geom_hline(yintercept = 0, linewidth = 0.4, color = "grey60") +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  facet_wrap(~ R0, nrow = 1, labeller = label_both) +
  scale_color_brewer(palette = "Dark2", name = "Catch-up") +
  scale_x_continuous("Routine coverage", breaks = seq(0.5, 0.95, by = 0.05), limits = c(0.5, 0.95)) +
  labs(
    title = "CRS averted over 25y vs routine (immediate campaign)",
    subtitle = "Baseline = routine 80%, no catch-up; colored by catch-up %",
    y = "Averted CRS (thousands)"
  ) +
  theme_bw(base_size = 14) +
  theme(legend.position = "top",
        panel.grid.minor = element_blank(),
        plot.title = element_text(face = "bold"))

ggsave("plots/sens_lines_immediate_25y.png", p_line_imm, width = 12, height = 4.5, dpi = 400)
message("Saved: plots/sens_lines_immediate_25y.png")

# ----------------------------
# 2) Mini-heatmap: timing effect at fixed (routine, catchup), per R0
# ----------------------------
routine_fix <- 0.90
catchup_fix <- 0.90

timing_mini <- sens_grid %>%
  filter(abs(routine - routine_fix) < 1e-9,
         abs(catchup - catchup_fix) < 1e-9,
         campaign %in% c("none","immediate","delayed1y","delayed2y","delayed3y")) %>%
  mutate(campaign = factor(campaign, levels = c("none","immediate","delayed1y","delayed2y","delayed3y")))

readr::write_csv(timing_mini, "outputs/sens_timing_mini.csv")

r0_ticks <- c(6, 7, 8)

p_timing_mini <- ggplot(timing_mini, aes(x = campaign, y = R0, fill = Averted25_base80)) +
  geom_tile(width = 0.8, height = 0.8) +
  scale_fill_viridis_c(name = "CRS averted (25y)") +
  scale_y_continuous(breaks = r0_ticks, labels = r0_ticks) +
  labs(
    title = sprintf("Timing effect at routine=%.0f%%, catch-up=%.0f%%", routine_fix*100, catchup_fix*100),
    subtitle = "Baseline = routine 80%, no catch-up",
    x = "Campaign timing", y = expression(R[0])
  ) +
  theme_bw(base_size = 14) +
  theme(legend.position = "right",
        panel.grid.minor = element_blank(),
        plot.title = element_text(face = "bold"))


ggsave("plots/sens_timing_mini_heatmap.png", p_timing_mini, width = 8, height = 4.5, dpi = 400)
message("Saved: plots/sens_timing_mini_heatmap.png")

# ----------------------------
# 3) Pareto-style scatter: Averted10 vs Averted25 (trade-off), colored by timing
#    Subset to a small grid to avoid clutter: routine ∈ {0.80, 0.90}, catch-up ∈ {0.60, 0.90}
# ----------------------------
routines_keep <- c(0.80, 0.90)
catch_keep    <- c(0.60, 0.90)
timings_keep  <- c("none","immediate","delayed1y","delayed2y","delayed3y")

pareto_slim <- sens_grid %>%
  filter(routine %in% routines_keep,
         catchup %in% catch_keep,
         campaign %in% timings_keep)

readr::write_csv(pareto_slim, "outputs/sens_pareto_slim.csv")

p_pareto <- ggplot(pareto_slim,
                   aes(x = Averted10_base80/1000, y = Averted25_base80/1000,
                       color = campaign, shape = factor(routine))) +
  geom_hline(yintercept = 0, color = "grey70", linewidth = 0.4) +
  geom_vline(xintercept = 0, color = "grey70", linewidth = 0.4) +
  geom_point(size = 4, alpha = 0.9) +
  facet_wrap(~ R0, nrow = 1, labeller = label_both) +
  scale_color_brewer(palette = "Set1", name = "Timing") +
  scale_shape_discrete(name = "Routine") +
  labs(
    title = "Short-term vs long-term impact (subset)",
    subtitle = "Averted CRS vs r80_none (10y on x-axis, 25y on y-axis)",
    x = "Averted CRS (10y, thousands)", y = "Averted CRS (25y, thousands)"
  ) +
  theme_bw(base_size = 14) +
  theme(legend.position = "right",
        panel.grid.minor = element_blank(),
        plot.title = element_text(face = "bold"))

ggsave("plots/sens_pareto_subset.png", p_pareto, width = 9, height = 3.5, dpi = 400)
message("Saved: plots/sens_pareto_subset.png")
```

```{r}
# --- Single-panel lines: Averted25 vs routine (immediate), fixed catch-up, color by R0 ---
# Purpose: show the three R0 lines together in one panel.

# Choose the catch-up level to hold fixed (change if needed)
catchup_fix <- 0.90

line_immediate_onepanel <- sens_grid %>%
  dplyr::filter(
    campaign == "immediate",
    abs(catchup - catchup_fix) < 1e-9
  )

# Save the exact data slice used (appendix-ready)
if (!dir.exists("outputs")) dir.create("outputs", recursive = TRUE)
readr::write_csv(line_immediate_onepanel, "outputs/sens_slice_immediate_lines_onepanel.csv")

p_line_imm_onepanel <- ggplot(line_immediate_onepanel,
                              aes(x = routine, y = Averted25_base80/1000, color = factor(R0))) +
  geom_hline(yintercept = 0, linewidth = 0.4, color = "grey60") +
  geom_line(linewidth = 1) +
  geom_point(size = 1.8) +
  scale_color_brewer(palette = "Dark2", name = expression(R[0])) +
  scale_x_continuous("Routine coverage", breaks = seq(0.5, 0.95, by = 0.05), limits = c(0.5, 0.95)) +
  labs(
    title = sprintf("CRS averted over 25y vs routine \n(immediate, catch-up = %.0f%%)", catchup_fix*100),
    subtitle = "Baseline = routine 80%, no catch-up",
    y = "Averted CRS (thousands)"
  ) +
  theme_bw(base_size = 12) +
  theme(legend.position = "right",
        panel.grid.minor = element_blank(),
        plot.title = element_text(face = "bold"))

ggsave("plots/sens_lines_immediate_25y_onepanel.png", p_line_imm_onepanel, width = 5, height = 4, dpi = 400)
message("Saved: plots/sens_lines_immediate_25y_onepanel.png")
```

```{r}
# --- Break-even routine threshold (25y, catch-up = 90%, immediate) ---------
sens_immed_90 <- sens_grid %>%
  dplyr::filter(campaign == "immediate", abs(catchup - 0.90) < 1e-9)

breakeven <- sens_immed_90 %>%
  dplyr::group_by(R0) %>%
  dplyr::arrange(routine, .by_group = TRUE) %>%
  dplyr::summarise(
    routine_break_even = {
      idx <- which(Averted25_base80 > 0)
      if (length(idx) == 0) NA_real_ else min(routine[idx])
    },
    .groups = "drop"
  )

p_be <- ggplot(sens_immed_90, aes(x = routine, y = Averted25_base80/1000, color = factor(R0))) +
  geom_line(linewidth = 1) + geom_point(size = 2) +
  geom_vline(data = breakeven, aes(xintercept = routine_break_even, color = factor(R0)),
             linetype = "dashed") +
  labs(title = "Break-even routine coverage (25y, catch-up 90% immediate)",
       subtitle = "Dashed = minimum routine where 25y averted CRS > 0 vs r80_none",
       x = "Routine coverage", y = "Averted CRS (thousands)", color = "R₀") +
  theme_bw(base_size = 14)

ggsave("plots/sens_breakeven_routine_25y.png", p_be, width = 9, height = 5, dpi = 400)
```

```{r}
# Mark cells that increase infections among females 15–44 vs baseline r80_none

# Build the baseline for cum_inf_F1544 per R0
base_infF <- sens_grid %>%
  filter(routine==0.80, catchup==0, campaign=="none") %>%
  select(R0, base_infF = cum_inf_F1544)

plot_df <- sens_grid %>%
  filter(campaign=="immediate") %>%
  left_join(base_infF, by="R0") %>%
  mutate(paradox_flag = cum_inf_F1544 > base_infF + 1e-9)  # TRUE = worse than baseline

gg <- ggplot(plot_df, aes(x=routine, y=catchup, fill=Averted25_base80)) +
  geom_tile() +
  geom_point(data=subset(plot_df, paradox_flag),
             aes(x=routine, y=catchup), shape=4, stroke=1.1, size=2, color="red") +
  facet_wrap(~R0, nrow=1, labeller=label_both) +
  scale_fill_viridis_c(option="C", name="CRS averted (25y)") +
  labs(title="Immediate campaign: CRS averted over 25y with paradox flags",
       subtitle="Red × = cumulative infections in females 15–44 exceed r80_none",
       x="Routine", y="Catch-up") +
  theme_bw(base_size=14)
ggsave("plots/sens_heatmap_immediate_25y_paradox.png", gg, width=12, height=4.5, dpi=400)
```

```{r}
# save top 5 options

# Top 5 strategies per R0 by 25y averted CRS (k = thousands)
top5 <- sens_grid %>%
  dplyr::filter(campaign != "none") %>%
  dplyr::group_by(R0) %>%
  dplyr::arrange(dplyr::desc(Averted25_base80), .by_group = TRUE) %>%
  dplyr::transmute(
    R0,
    Routine = routine,
    CatchUp = catchup,
    Timing  = as.character(campaign),
    `Averted CRS (25y, k)` = round(Averted25_base80 / 1000, 1)
  ) %>%
  dplyr::slice_head(n = 5) %>%
  dplyr::ungroup()

readr::write_csv(top5, "outputs/sens_top5_per_R0_25y.csv")
top5
```

