---
title: "Main Analysis"
author: "Andomei Smit: SMTAND051"
date: "30/09/2025"
output:
  bookdown::pdf_document2:
    toc: true
    toc_depth: 2
    fig_caption: true
    keep_tex: true
---

# Setup

```{r}
# ---- setup: packages & knitr ----
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(readr); library(dplyr); library(tidyr); library(stringr); library(tibble)
library(deSolve)
library(knitr)

# ---- load config knobs ----
source("R/config.R")
# ---- load the engine functions (purl'ed script) ----
source("R/engine.R")
```

# Load data

```{r}
# ---- data: load processed inputs ----
proc_dir <- "data/processed"

# Population at start_year (sex, age, pop)
pop_sy <- readr::read_csv(file.path(proc_dir, "pop_age_sex.csv"), show_col_types = FALSE) |>
  dplyr::filter(year == start_year) |>
  dplyr::select(sex, age, pop)

# Mortality for the whole simulation window (year, sex, age, mu)
sim_years <- start_year:(start_year + horizon_years - 1)
mu_tbl <- readr::read_csv(file.path(proc_dir, "mortality_singleyear.csv"), show_col_types = FALSE) |>
  dplyr::filter(year %in% sim_years) |>
  dplyr::select(year, sex, age, mu)

# Births, coverage, pregnancy prevalence
births_df   <- readr::read_csv(file.path(proc_dir, "births.csv"), show_col_types = FALSE)
coverage_df <- readr::read_csv(file.path(proc_dir, "coverage.csv"), show_col_types = FALSE)
preg_prev   <- readr::read_csv(file.path(proc_dir, "pregnancy_prevalence.csv"), show_col_types = FALSE)

# ---- calibration: load WHO fit data ----
# Uses data/processed/cases_fit.csv that was created in Data prep
cases_fit <- readr::read_csv("data/processed/cases_fit.csv", show_col_types = FALSE)
stopifnot(all(c("year","cases_reported_total") %in% names(cases_fit)))


# ---- guardrails: inputs must cover sim years & plausible ranges ----
stopifnot(all(sim_years %in% unique(mu_tbl$year)))
stopifnot(all(sim_years %in% unique(births_df$year)))
stopifnot(all(sim_years %in% unique(coverage_df$year)))
stopifnot(all(preg_prev$age >= 15 & preg_prev$age <= 44))
```

# Quick smoke test

```{r}
# ---- build model object ----
mdl <- build_model(
  ages        = ages,
  sexes       = sexes,
  pop_sy      = pop_sy,
  mu_tbl      = mu_tbl,
  births_df   = births_df,
  coverage_df = coverage_df,
  preg_prev   = preg_prev
)

# ---- initial state (seeds 1 infection per (sex,age) cell) ----
y0 <- build_initial_state(mdl, seed_I_per_cell = 1L)

# ---- parameters (placeholders; beta & rho will be fitted later) ----
parms <- list(
  sigma = 1 / latent_period_years,
  gamma = 1 / infectious_period_years,
  beta  = beta,   # from config.R (placeholder)
  rho   = rho,    # from config.R (placeholder)
  VE    = VE
)

# ---- tiny smoke test: 2 years to verify ODE + events + μ-by-year ----
smoke <- run_horizon_mdl(
  y_start     = y0,
  start_year  = start_year,
  n_years     = 2,
  pr          = parms,
  mdl         = mdl,
  share_F     = share_F,
  share_M     = share_M,
  crs_parms   = crs_parms,
  tri_weights = tri_weights
)

smoke$results
```

# Burn-in

We want the model to start at a plausible endemic state, thus we simulate the model for K years prior to the window of the analysis for it to reach equilibrium.

```{r}
# ---- burn-in config knobs ----
burn_in_years <- 30          # set 0 to skip burn-in entirely
burn_ref_year <- start_year  # reuse demography from this year during burn-in

# Target R0 during burn-in (plausible pre-vax rubella 5–8). Converted to beta via beta = R0 * gamma.
R0_burnin <- 8
```

```{r}
# ---- burn-in run  ----
# Build a parameter list used ONLY during burn-in. We swap in beta to match R0_burnin.
parms_pre <- list(
  sigma = 1 / latent_period_years,
  gamma = 1 / infectious_period_years,
  beta  = R0_burnin * (1 / infectious_period_years),  # beta = R0 * gamma
  rho   = rho,   # unused in burn-in; harmless placeholder
  VE    = VE,     # unused in burn-in (no vaccination); harmless placeholder
  eps = 1e-8
)

# Either do burn-in (K > 0) or just pass through y0
if (burn_in_years > 0) {
  message("Burn-in: K=", burn_in_years, " years; R0=", R0_burnin,
          " (beta=", round(parms_pre$beta, 3), "); stationary demography from ", burn_ref_year)
  y_start_policy <- burn_in_mdl(
    y_start   = y0,
    start_year = start_year,
    K          = burn_in_years,
    pr         = parms_pre,
    mdl        = mdl,
    ref_year   = burn_ref_year,
    share_F    = share_F,
    share_M    = share_M
  )
} else {
  message("Burn-in skipped; using y0 directly.")
  y_start_policy <- y0
}
```
```{r}
# ---- post-burn-in smoke test ----
# Policy parameters (still placeholders; we'll fit beta & rho in Step 3)
parms_policy <- list(
  sigma = 1 / latent_period_years,
  gamma = 1 / infectious_period_years,
  beta  = beta,
  rho   = rho,
  VE    = VE
)

smoke_after_burnin <- run_horizon_mdl(
  y_start     = y_start_policy,
  start_year  = start_year,
  n_years     = 2,              # just a short check
  pr          = parms_policy,
  mdl         = mdl,
  share_F     = share_F,
  share_M     = share_M,
  crs_parms   = crs_parms,
  tri_weights = tri_weights
)

smoke_after_burnin$results
```
```{r}
# ---- optional diagnostics ----
cat("Policy R0 ≈ ", round(parms_policy$beta / parms_policy$gamma, 3), "\n")

N0 <- sum(y_start_policy[mdl$idx$S] + y_start_policy[mdl$idx$E] +
          y_start_policy[mdl$idx$I] + y_start_policy[mdl$idx$R])
cat("Total population at policy start: ", format(N0, big.mark=","), "\n")

I0 <- sum(y_start_policy[mdl$idx$I])
cat("Infectious at policy start (sum over all ages/sexes): ", round(I0), "\n")
```

```{r}
# Inspect infectious prevalence after burn-in with more precision
I0      <- sum(y_start_policy[mdl$idx$I])
N0      <- sum(y_start_policy[mdl$idx$S] + y_start_policy[mdl$idx$E] +
               y_start_policy[mdl$idx$I] + y_start_policy[mdl$idx$R])
prev_I0 <- I0 / N0

cat(sprintf("I0 (exact) = %.6f\n", I0))
cat(sprintf("N0 (exact) = %.0f\n", N0))
cat(sprintf("Prev_I0 = %.8f (%.3f per 100k)\n", prev_I0, prev_I0*1e5))

```

# Validate the R0 and rho values found in literature

```{r}
# ---- calibration: validation-only obs vs exp (literature-locked) ----
# Fitting/validation window and reference demography for stationary runs
fit_years      <- 2012:2019
fit_ref_demog  <- start_year         # use mortality from policy start for stationary demography
R0_lit_central <- 7.5                # literature anchor
rho_lit_central <- 0.005             # literature anchor for reporting

# Parameters for the stationary, no-vaccination fit-window run
parms_fit <- list(
  sigma = 1 / latent_period_years,
  gamma = 1 / infectious_period_years,
  beta  = R0_lit_central * (1 / infectious_period_years),
  rho   = rho_lit_central,
  VE    = VE,
  eps   = 1e-8
)

# Burn-in ending just before the first fit year, under the same parameters
burnin_years_fit <- 20
y_burn_fit <- burn_in_mdl(
  y_start    = y0,
  start_year = min(fit_years),
  K          = burnin_years_fit,
  pr         = parms_fit,
  mdl        = mdl,
  ref_year   = fit_ref_demog,
  share_F    = share_F,
  share_M    = share_M
)

# Stationary, no-vaccination simulation across fit years
sim_fit <- run_stationary_novax(
  y_start = y_burn_fit,
  years   = fit_years,
  pr      = parms_fit,
  mdl     = mdl,
  ref_year = fit_ref_demog,
  share_F = share_F,
  share_M = share_M
)

# Observed vs expected (literature-locked)
fit_compare_locked <- cases_fit %>%
  dplyr::filter(year %in% fit_years) %>%
  dplyr::inner_join(sim_fit$results %>% dplyr::select(year, infections_total), by = "year") %>%
  dplyr::transmute(
    year,
    obs = cases_reported_total,
    exp_locked = parms_fit$rho * infections_total
  )

print(fit_compare_locked)

# Optional: a one-parameter rescale of rho to match mean level (not a full likelihood fit)
rho_hat <- sum(fit_compare_locked$obs, na.rm = TRUE) / sum(sim_fit$results$infections_total, na.rm = TRUE)
fit_compare_scaled <- fit_compare_locked %>%
  dplyr::mutate(exp_scaled = rho_hat * (sim_fit$results$infections_total[match(year, sim_fit$results$year)]))

cat(sprintf("rho_lit_central = %.5f; rho_hat (mean-level) = %.5f\n", rho_lit_central, rho_hat))

# Quick plot: Observed vs Expected
plot(fit_compare_locked$year, fit_compare_locked$obs, type = "b", pch = 16,
     xlab = "Year", ylab = "Reported cases",
     main = "Observed vs expected (literature-locked R0, rho; stationary demography)", ylim = c(0, max(fit_compare_locked$exp_locked)))
lines(fit_compare_locked$year, fit_compare_locked$exp_locked, type = "b", pch = 1, lty = 2)
legend("topright", legend = c("Observed", "Expected (literature)"),
       pch = c(16,1), lty = c(1,2), bty = "n")

# (Optional) Overlay the level-matched expected series
lines(fit_compare_scaled$year, fit_compare_scaled$exp_scaled, type = "b", pch = 0, lty = 3)
legend("topleft", legend = c("Expected (scaled rho)"), pch = 0, lty = 3, bty = "n")


# only plot scaled rho with observed
plot(fit_compare_locked$year, fit_compare_locked$obs, type = "b", pch = 16,
     xlab = "Year", ylab = "Reported cases",
     main = "Observed vs expected (literature-locked R0, rho; stationary demography)", ylim = c(0, max(fit_compare_scaled$exp_scaled)))
#lines(fit_compare_locked$year, fit_compare_locked$exp_locked, type = "b", pch = 1, lty = 2)
lines(fit_compare_scaled$year, fit_compare_scaled$exp_scaled, type = "b", pch = 0, lty = 3)
legend("topright", legend = c("Observed", "Expected (scaled rho)"),
       pch = c(16,0), lty = c(1,3), bty = "n")

legend("topright", legend = c("Expected (scaled rho)"), pch = 0, lty = 3, bty = "n")

```

# Add diagnostics for mean age of infection

```{r}
# ---------------------------------------------
# Helper: mean age at infection among females 15–44
# Inputs:
#   C_F_vec : numeric vector of length mdl$n_age; infections in females by single-year age
#   mdl     : model object (to access 'ages')
# Returns:
#   Weighted mean age over ages 15..44, or NA if no infections in that range
mean_age_infection_f1544 <- function(C_F_vec, mdl) {
  stopifnot(length(C_F_vec) == mdl$n_age)
  a <- mdl$ages
  sel <- (a >= 15 & a <= 44)
  w <- C_F_vec[sel]
  if (sum(w) <= 0) return(NA_real_)
  sum(a[sel] * w) / sum(w)
}

# ---------------------------------------------
# Runner that adds "paradox" diagnostics
# Mirrors run_horizon_mdl, but also records:
#   - inf_F1544        : infections in females aged 15–44 (per year)
#   - mean_age_F1544   : mean age of infection in females 15–44 (per year)
#
# Note: We reuse the same ODE + events; we only add post-processing.
run_horizon_with_paradox <- function(y_start, start_year, n_years, pr, mdl, share_F, share_M, crs_parms, tri_weights) {
  yrs <- seq.int(from = start_year, length.out = n_years)
  out <- tibble::tibble(
    year = integer(),
    infections_total = double(),
    reported_cases   = double(),
    crs              = double(),
    inf_F1544        = double(),
    mean_age_F1544   = double()
  )

  y_curr <- y_start

  for (yr in yrs) {
    # Reset yearly counters (accumulators) before integrating the year
    y_curr[mdl$idx$C_F]  <- 0
    y_curr[mdl$idx$C_tot] <- 0

    # Integrate ODE over the calendar year and apply events
    res   <- simulate_one_year_mdl(y_curr, yr, pr, mdl, share_F, share_M)

    # Read end-of-year accumulators BEFORE events are applied
    y_pre <- as.numeric(res$trajectory[nrow(res$trajectory), -1])
    C_F_end   <- y_pre[mdl$idx$C_F]           # female infections by age
    C_tot_end <- as.numeric(y_pre[mdl$idx$C_tot])

    # Compute CRS using your existing helper
    crs_year <- crs_from_infections_mdl(C_F_end, mdl, r = crs_parms, w = tri_weights)

    # Compute paradox diagnostics
    a <- mdl$ages
    sel <- (a >= 15 & a <= 44)
    inf_F1544      <- sum(C_F_end[sel])
    mean_age_F1544 <- mean_age_infection_f1544(C_F_end, mdl)

    out <- dplyr::bind_rows(out, tibble::tibble(
      year = yr,
      infections_total = C_tot_end,
      reported_cases   = if (!is.null(pr$rho) && is.finite(pr$rho)) pr$rho * C_tot_end else NA_real_,
      crs              = crs_year,
      inf_F1544        = inf_F1544,
      mean_age_F1544   = mean_age_F1544
    ))

    # Roll state forward (post-events state becomes next year's start)
    y_curr <- res$y_next
  }

  list(results = out, y_final = y_curr)
}
```

# Policy Scenario Testing

```{r}
# ---- Build a coverage table for a scenario (with optional age-band) ----
# years         : integer vector for policy years
# p_routine     : routine coverage in [0,1]
# campaign_year : integer year for one-time catch-up (or NULL for none)
# p_catchup     : catch-up coverage in [0,1]
# catch_min_age : integer lower bound (default 1)
# catch_max_age : integer upper bound, inclusive (default 14)
# catch_age0_frac : numeric in (0,1], only used if min_age == 0 (default NA => treat as 1 for age 0)
make_coverage_scenario <- function(
    years,
    p_routine,
    campaign_year = NULL,
    p_catchup     = NULL,
    catch_min_age = 1L,
    catch_max_age = 14L,
    catch_age0_frac = NA_real_
) {
  stopifnot(p_routine >= 0, p_routine <= 1)

  cov <- tibble::tibble(
    year = years,
    routine_coverage = p_routine,
    catchup_coverage = NA_real_,
    catch_min_age    = as.integer(catch_min_age),
    catch_max_age    = as.integer(catch_max_age),
    catch_age0_frac  = as.numeric(catch_age0_frac)
  )

  if (!is.null(campaign_year)) {
    stopifnot(campaign_year %in% years)
    stopifnot(!is.null(p_catchup), p_catchup >= 0, p_catchup <= 1)
    cov$catchup_coverage[cov$year == campaign_year] <- p_catchup
  }

  cov
}
```


```{r}
# define and run scenarios
# ---------------------------------------------
# Helper: shallow-clone the model and override coverage
clone_with_coverage <- function(mdl, coverage_new) {
  mdl2 <- mdl
  mdl2$coverage_df <- coverage_new
  mdl2
}

# ---- helpers: campaign labeling and zero-vax delay handling ----

# ---- helper: vectorized campaign label -----------------------------------
campaign_label <- function(campaign_year, start_year) {
  # Returns "none", "immediate", or "delayed{k}y" for each element of campaign_year
  out <- ifelse(
    is.na(campaign_year), "none",
    ifelse(
      campaign_year == start_year, "immediate",
      paste0("delayed", as.integer(campaign_year - start_year), "y")
    )
  )
  out
}


# ---- helper: delay handling with optional routine suspension -------------
# Suppress catch-up before the campaign year. Optionally set routine=0
# during the delay window (years: start_year .. campaign_year-1).
apply_delay <- function(cov_tbl, start_year, campaign_year, zero_routine = TRUE) {
  if (is.na(campaign_year) || campaign_year <= start_year) return(cov_tbl)
  delay_years <- seq.int(start_year, campaign_year - 1L)
  # Catch-up is always absent before the campaign
  cov_tbl$catchup_coverage[cov_tbl$year %in% delay_years] <- NA_real_
  # Optionally suspend routine during the delay
  if (isTRUE(zero_routine)) {
    cov_tbl$routine_coverage[cov_tbl$year %in% delay_years] <- 0
  }
  cov_tbl
}
```


Compare multiple years.

```{r}
# Compute CRS over an arbitrary window from a results data frame
crs_sum_window <- function(df, start_year, years) {
  stopifnot(all(c("year","crs") %in% names(df)))
  yr_max <- start_year + years - 1L
  sum(df$crs[df$year >= start_year & df$year <= yr_max], na.rm = TRUE)
}
```

```{r}
# ---------------------------------------------
# Define locked literature parameters/burn-in
R0_lit_central   <- 7.9            # SA anchor; vary in sensitivity later
rho_lit_central  <- 0.01

parms_locked <- list(
  sigma = 1 / latent_period_years,
  gamma = 1 / infectious_period_years,
  beta  = R0_lit_central * (1 / infectious_period_years),
  rho   = rho_lit_central,
  VE    = VE,
  eps   = 1e-8
  )

y_start_locked <- burn_in_mdl(
 y_start    = y0,
  start_year = start_year,
  K          = 30, # 30 year burn in
  pr         = parms_locked,
  mdl        = mdl,
  ref_year   = start_year,
  share_F    = share_F,
  share_M    = share_M
)
```


```{r}
# ---- scenarios: define with campaign_year; labels derived by helper ----

# Policy years
years_policy <- start_year:(start_year + horizon_years - 1)

# Define a compact set of illustrative scenarios (mix of routine, catch-up %, and delays)
# ---- scenarios: add age-band columns and two 9m–9y variants ----
scenarios <- tibble::tibble(
  id         = c("r80_none", "r90_none",
                 "r80_c90_now", "r90_c90_now",
                 "r90_c90_d1", "r90_c90_d2", "r90_c90_d3",
                 "r90_c90_d1_keepR", "r90_c90_d2_keepR", "r90_c90_d3_keepR",
                 "r90_c90_now_9m9y", "r90_c90_d1_9m9y_keepR"),
  routine    = c(0.80, 0.90,
                 0.80, 0.90,
                 0.90, 0.90, 0.90,
                 0.90, 0.90, 0.90,
                 0.90, 0.90),
  catch_cov  = c(NA,   NA,
                 0.90, 0.90,
                 0.90, 0.90, 0.90,
                 0.90, 0.90, 0.90,
                 0.90, 0.90),
  catch_year = c(NA,   NA,
                 start_year, start_year,
                 start_year + 1L, start_year + 2L, start_year + 3L,
                 start_year + 1L, start_year + 2L, start_year + 3L,
                 start_year,       start_year + 1L),
  delay_zero_routine = c(FALSE, FALSE,
                         FALSE, FALSE,
                         TRUE, TRUE, TRUE,
                         FALSE, FALSE, FALSE,
                         FALSE, FALSE),
  # Default band: 1–14 (full age-0 not used)
  catch_min_age = c(rep(1L, 10),   0L,              0L),
  catch_max_age = c(rep(14L, 10),  9L,              9L),
  catch_age0_frac = c(rep(NA_real_, 10), 0.25,      0.25)
) %>%
  dplyr::mutate(
    band_label = dplyr::if_else(catch_min_age == 0L,
                                "9m–9y", "1–14y"),
    label = dplyr::case_when(
      is.na(catch_year) ~ paste0("Routine ", scales::percent(routine), " (no catch-up)"),
      !delay_zero_routine & (catch_year > start_year) ~ paste0(
        "Catch-up ", band_label, " @", scales::percent(catch_cov),
        " (", campaign_label(catch_year, start_year), ", routine ON), Routine ", scales::percent(routine)
      ),
      TRUE ~ paste0(
        "Catch-up ", band_label, " @", scales::percent(catch_cov),
        " (", campaign_label(catch_year, start_year), "), Routine ", scales::percent(routine)
      )
    )
  )


# ---- run scenarios using generic delay handler + auto labels ----
scenario_results <- list()

for (i in seq_len(nrow(scenarios))) {
  sc <- scenarios[i, ]

  # Build coverage for this scenario
  # Build coverage for this scenario (pass age-band parameters)
  cov_tbl <- make_coverage_scenario(
    years           = years_policy,
    p_routine       = sc$routine,
    campaign_year   = if (is.na(sc$catch_year)) NULL else sc$catch_year,
    p_catchup       = if (is.na(sc$catch_cov))  NULL else sc$catch_cov,
    catch_min_age   = sc$catch_min_age,
    catch_max_age   = sc$catch_max_age,
    catch_age0_frac = sc$catch_age0_frac
  )

  # Enforce delay rule: always suppress catch-up before campaign; optionally suspend   routine
  cov_tbl <- apply_delay(
    cov_tbl,
    start_year     = start_year,
    campaign_year  = sc$catch_year,
    zero_routine   = sc$delay_zero_routine
  )

  # Clone model with scenario-specific coverage
  mdl_sc <- clone_with_coverage(mdl, cov_tbl)

  # Run with paradox diagnostics
  run_sc <- run_horizon_with_paradox(
    y_start     = y_start_locked,
    start_year  = start_year,
    n_years     = horizon_years,
    pr          = parms_locked,
    mdl         = mdl_sc,
    share_F     = share_F,
    share_M     = share_M,
    crs_parms   = crs_parms,
    tri_weights = tri_weights
  )

  df <- run_sc$results

  CRS10_val <- crs_sum_window(df, start_year = start_year, years = 10)
  CRS25_val <- crs_sum_window(df, start_year = start_year, years = 25)

  scenario_results[[sc$id]] <- list(
    summary  = tibble::tibble(
    id         = sc$id,
    label      = sc$label,
    routine    = sc$routine,
    catch_year = sc$catch_year,
    catch_cov  = sc$catch_cov,
    campaign   = campaign_label(sc$catch_year, start_year),
    CRS10      = CRS10_val,
    CRS25      = CRS25_val,
    cum_inf_F1544      = sum(df$inf_F1544, na.rm = TRUE),
    mean_age_F1544_avg = mean(df$mean_age_F1544, na.rm = TRUE)
  ),
  timeseries = df,
  coverage   = cov_tbl
)
}

# Collect a summary table
scenario_summary <- dplyr::bind_rows(lapply(scenario_results, `[[`, "summary")) %>%
  dplyr::arrange(CRS10)
```

How much better is this than baseline.

```{r}
# ---- CRS averted vs baseline (baseline = Routine 80% + no catch-up) ----
# Select baseline row dynamically (in case labels/ids change)
# Choose which horizon to compare
metric <- "CRS10"   # or "CRS25"

baseline_row <- scenario_summary %>%
  dplyr::filter(is.na(catch_year), abs(routine - 0.80) < 1e-9) %>%
  dplyr::slice(1)

stopifnot(nrow(baseline_row) == 1)
base_val <- baseline_row[[metric]]

scenario_summary <- scenario_summary %>%
  dplyr::mutate(
    Averted = base_val - .data[[metric]]
  ) %>%
  dplyr::arrange(dplyr::desc(Averted))
```

# Sensitivity check

```{r}
# ---------------------------------------------
# Expanded sensitivity grid definitions
# - R0: keep literature-reasonable values
# - Routine: 50%..95% in 5% steps
# - Catch-up: 0%..95% in 10% steps (0 means no campaign)
# - Campaign timing: immediate (start_year) vs delayed (1, 2 and 3y)

# ---- sensitivity grid options (expanded) ----
R0_vals_exp        <- c(6.0, 7.0, 8.0)
routine_vals_exp   <- seq(0.50, 0.95, by = 0.05)
catch_vals_exp     <- seq(0.00, 0.95, by = 0.10)  # 0 = no catch-up
campaign_year_opts <- c(start_year, start_year + 1L, start_year + 2L, start_year + 3L)  # immediate, +1y, +2y, +3y
```


```{r}
# ---------------------------------------------
# Run the expanded grid
# For each (R0, routine, catch-up %), evaluate:
#   - immediate campaign at start_year
#   - delayed campaign (start_year + 3)
# Special case: if catch-up == 0, we only run "no campaign" (i.e., 'immediate' slot carries no campaign).

sens_rows_exp <- list()
row_id <- 0L

for (R0v in R0_vals_exp) {
  parms_sens <- parms_locked
  parms_sens$beta <- R0v * parms_locked$gamma

  for (pr in routine_vals_exp) {
    for (pc in catch_vals_exp) {

      # Decide which campaign years to evaluate for this catch-up %
      camp_years_this <- if (pc == 0) NA_integer_ else campaign_year_opts

      for (cy in camp_years_this) {

        # Build coverage table
        cov_tbl <- make_coverage_scenario(
          years         = years_policy,
          p_routine     = pr,
          campaign_year = if (is.na(cy)) NULL else cy,
          p_catchup     = if (is.na(cy)) NULL else pc
        )

        # Apply zero-vax during delay window (generic)
        cov_tbl <- apply_delay(cov_tbl, start_year = start_year, campaign_year = cy)

        # Clone model with coverage
        mdl_sc <- clone_with_coverage(mdl, cov_tbl)

        # Run horizon
        run_sc <- run_horizon_with_paradox(
          y_start     = y_start_locked,
          start_year  = start_year,
          n_years     = horizon_years,
          pr          = parms_sens,
          mdl         = mdl_sc,
          share_F     = share_F,
          share_M     = share_M,
          crs_parms   = crs_parms,
          tri_weights = tri_weights
        )

        df <- run_sc$results

        row_id <- row_id + 1L
        sens_rows_exp[[row_id]] <- tibble::tibble(
          R0          = R0v,
          routine     = pr,
          catchup     = pc,
          campaign    = if (pc == 0) "none" else campaign_label(cy, start_year),
          campaign_year = if (pc == 0) NA_integer_ else cy,
          CRS10       = sum(df$crs, na.rm = TRUE),
          cum_inf_F1544      = sum(df$inf_F1544, na.rm = TRUE),
          mean_age_F1544_avg = mean(df$mean_age_F1544, na.rm = TRUE)
        )
      }
    }
  }
}

sens_expanded <- dplyr::bind_rows(sens_rows_exp)

# Baseline per R0 for "CRS averted" comparisons (routine 80%, no catch-up, campaign='none')
baseline_key <- sens_expanded %>%
  dplyr::filter(routine == 0.80, catchup == 0, campaign == "none") %>%
  dplyr::select(R0, baseline_CRS10 = CRS10)

sens_expanded2 <- sens_expanded %>%
  dplyr::left_join(baseline_key, by = "R0") %>%
  dplyr::mutate(CRS10_averted = baseline_CRS10 - CRS10)

# Ensure campaign facet order
campaign_levels <- c("none", "immediate", "delayed1y", "delayed2y", "delayed3y")
sens_expanded2 <- sens_expanded2 %>%
  dplyr::mutate(campaign = factor(campaign, levels = campaign_levels))
```

```{r}
# Quick view: best options per R0 (top 10 by CRS averted)
best_per_R0 <- sens_expanded2 |>
  dplyr::group_by(R0) |>
  dplyr::arrange(dplyr::desc(CRS10_averted), .by_group = TRUE) |>
  dplyr::slice_head(n = 10L) |>
  dplyr::ungroup()
```

## CRS Heatmap

```{r}
# ---------------------------------------------
# Heatmaps of CRS averted, plus paradox markers
library(ggplot2)

# 1) CRS averted heatmap (per R0, by campaign timing)
ggplot(sens_expanded2, aes(x = routine, y = catchup, fill = CRS10_averted)) +
  geom_tile() +
  facet_grid(R0 ~ campaign, labeller = label_both) +
  scale_fill_viridis_c(option = "C", name = "CRS averted (10y)") +
  scale_x_continuous("Routine coverage", breaks = seq(0.5, 0.95, by = 0.05)) +
  scale_y_continuous("Catch-up coverage", breaks = seq(0.0, 0.95, by = 0.10)) +
  labs(title = "CRS averted vs baseline (routine 80%, no catch-up)",
       subtitle = "Facets by R0 and campaign timing; higher = better") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "right")

# 2) Add paradox flag (TRUE if cum_inf_F1544 <= baseline at same R0)
#    First compute the baseline cum_inf_F1544 per R0 (routine=0.80, catchup=0, campaign='none')
baseline_infF <- sens_expanded2 |>
  dplyr::filter(routine == 0.80, catchup == 0, campaign == "none") |>
  dplyr::select(R0, base_infF = cum_inf_F1544)

sens_plot <- sens_expanded2 |>
  dplyr::left_join(baseline_infF, by = "R0") |>
  dplyr::mutate(
    paradox_ok = cum_inf_F1544 <= base_infF + 1e-9  # allow tiny numerical wiggle
  )

# Heatmap with markers: red "✖" where paradox is violated
ggplot(sens_plot, aes(x = routine, y = catchup, fill = CRS10_averted)) +
  geom_tile() +
  geom_point(data = subset(sens_plot, !paradox_ok),
             aes(x = routine, y = catchup),
             shape = 4, size = 2.2, stroke = 1.1, color = "red") +
  facet_grid(R0 ~ campaign, labeller = label_both) +
  scale_fill_viridis_c(option = "C", name = "CRS averted (10y)") +
  scale_x_continuous("Routine coverage", breaks = seq(0.5, 0.95, by = 0.05)) +
  scale_y_continuous("Catch-up coverage", breaks = seq(0.0, 0.95, by = 0.10)) +
  labs(title = "CRS averted with paradox violations marked",
       subtitle = "Red ✖ indicates infections in females 15–44 increased vs baseline") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "right")

# Optional: save to disk
#out_dir <- "outputs"
#if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
#ggsave(file.path(out_dir, "heatmap_CRS_averted.png"), width = 10, height = 7, dpi = 300)
#ggsave(file.path(out_dir, "heatmap_CRS_averted_paradox.png"), width = 10, height = 7, dpi = 300)
```

```{r}
# Keep only panels where catch-up actually varies
df_heat <- sens_expanded2 |> dplyr::filter(campaign != "none")

library(ggplot2)

# Heatmap: CRS averted, only for "now" and "delay3y"
p_heat <- ggplot(df_heat, aes(x = routine, y = catchup, fill = CRS10_averted)) +
  geom_tile() +
  facet_grid(R0 ~ campaign, labeller = label_both) +
  scale_fill_viridis_c(option = "C", name = "CRS averted (10y)") +
  scale_x_continuous("Routine coverage", breaks = seq(0.5, 0.95, by = 0.05), limits = c(0.5, 0.95)) +
  scale_y_continuous("Catch-up coverage", breaks = seq(0, 0.95, by = 0.10), limits = c(0, 0.95)) +
  labs(title = "CRS averted vs baseline (routine 80%, no catch-up)",
       subtitle = "Panels only where catch-up occurs") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "right")

p_heat

# Optional paradox overlay (red ✖ where paradox is violated)
baseline_infF <- sens_expanded2 |>
  dplyr::filter(routine == 0.80, catchup == 0, campaign == "none") |>
  dplyr::select(R0, base_infF = cum_inf_F1544)

df_heat_mark <- df_heat |>
  dplyr::left_join(baseline_infF, by = "R0") |>
  dplyr::mutate(paradox_ok = cum_inf_F1544 <= base_infF + 1e-9)

p_heat_mark <- ggplot(df_heat_mark, aes(x = routine, y = catchup, fill = CRS10_averted)) +
  geom_tile() +
  geom_point(data = subset(df_heat_mark, !paradox_ok),
             aes(x = routine, y = catchup),
             shape = 4, size = 2.2, stroke = 1.1, color = "red") +
  facet_grid(R0 ~ campaign, labeller = label_both) +
  scale_fill_viridis_c(option = "C", name = "CRS averted (10y)") +
  scale_x_continuous("Routine coverage", breaks = seq(0.5, 0.95, by = 0.05), limits = c(0.5, 0.95)) +
  scale_y_continuous("Catch-up coverage", breaks = seq(0, 0.95, by = 0.10), limits = c(0, 0.95)) +
  labs(title = "CRS averted (paradox violations marked)",
       subtitle = "Red ✖ indicates infections in females 15–44 increased vs baseline") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "right")

p_heat_mark

# Separate, simple plot for "no campaign" (catchup = 0 always)
df_none <- sens_expanded2 |> dplyr::filter(campaign == "none") |>
  dplyr::arrange(R0, routine)

p_none <- ggplot(df_none, aes(x = routine, y = CRS10_averted, group = R0, color = as.factor(R0))) +
  geom_line() + geom_point() +
  scale_x_continuous("Routine coverage", breaks = seq(0.5, 0.95, by = 0.05), limits = c(0.5, 0.95)) +
  labs(y = "CRS averted (10y) vs baseline", color = "R0",
       title = "Routine-only policies (no catch-up)") +
  theme_minimal(base_size = 12)

p_none
```


